<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Mine Cart Tracks - Live Edit</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
  }
  #toolbar {
    position: fixed;
    top: 8px;
    left: 8px;
    z-index: 10;
    display: flex;
    gap: 8px;
  }
  #toolbar button {
    background: #222;
    color: #f2f2f2;
    border: 1px solid #555;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 13px;
  }
  #toolbar button:hover {
    background: #333;
  }
  #container {
    display: flex;
    width: 100vw;
    height: 100vh;
  }
  #c {
    width: 50vw;
    height: 100vh;
    display: block;
    background: black;
  }
  #editor {
    width: 50vw;
    height: 100vh;
    background: #111;
    color: #ddd;
    font-family: monospace;
    font-size: 14px;
    border: none;
    outline: none;
    padding: 8px;
    resize: none;
  }
</style>
</head>
<body>

<div id="toolbar">
  <button id="pauseBtn">Pause</button>
  <button id="restartBtn">Restart</button>
</div>

<div id="container">
  <canvas id="c"></canvas>
  <textarea id="editor"></textarea>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const editor = document.getElementById("editor");
const pauseBtn = document.getElementById("pauseBtn");
const restartBtn = document.getElementById("restartBtn");
const CODE_PREFIX = `(function () {
  "use strict";
  const __hooks = arguments[2] || {};
  const requestAnimationFrame = __hooks.requestAnimationFrame || window.requestAnimationFrame.bind(window);
  const cancelAnimationFrame = __hooks.cancelAnimationFrame || window.cancelAnimationFrame.bind(window);
`;
const CODE_SUFFIX = '\n})();';

function createAnimationController() {
  const nativeRAF = window.requestAnimationFrame.bind(window);
  const nativeCancel = window.cancelAnimationFrame.bind(window);
  let paused = false;
  let nextHandle = 1;
  const entries = new Map();
  let prevRAF = null;
  let prevCancel = null;

  function schedule(handle) {
    const entry = entries.get(handle);
    if (!entry || entry.cancelled) return;
    entry.pending = false;
    entry.nativeHandle = nativeRAF((ts) => {
      entry.nativeHandle = null;
      if (paused || entry.cancelled) {
        entry.pending = true;
        return;
      }
      entries.delete(handle);
      entry.callback(ts);
    });
  }

  function requestFrame(cb) {
    const handle = nextHandle++;
    entries.set(handle, {
      callback: cb,
      nativeHandle: null,
      cancelled: false,
      pending: false
    });
    if (!paused) schedule(handle);
    else entries.get(handle).pending = true;
    return handle;
  }

  function cancelFrame(handle) {
    const entry = entries.get(handle);
    if (!entry) return;
    entry.cancelled = true;
    if (entry.nativeHandle !== null) {
      nativeCancel(entry.nativeHandle);
    }
    entries.delete(handle);
  }

  function pause() {
    if (paused) return;
    paused = true;
    for (const entry of entries.values()) {
      if (entry.nativeHandle !== null) {
        nativeCancel(entry.nativeHandle);
        entry.nativeHandle = null;
      }
      entry.pending = true;
    }
  }

  function resume() {
    if (!paused) return;
    paused = false;
    for (const [handle, entry] of entries) {
      if (!entry.cancelled && (entry.pending || entry.nativeHandle === null)) {
        entry.pending = false;
        schedule(handle);
      }
    }
  }

  function dispose() {
    for (const [handle, entry] of entries) {
      if (entry.nativeHandle !== null) {
        nativeCancel(entry.nativeHandle);
      }
    }
    entries.clear();
    paused = false;
    restoreGlobals();
  }

  function installGlobals() {
    if (prevRAF !== null) return;
    prevRAF = window.requestAnimationFrame;
    prevCancel = window.cancelAnimationFrame;
    window.requestAnimationFrame = requestFrame;
    window.cancelAnimationFrame = cancelFrame;
  }

  function restoreGlobals() {
    if (prevRAF === null) return;
    window.requestAnimationFrame = prevRAF;
    window.cancelAnimationFrame = prevCancel;
    prevRAF = null;
    prevCancel = null;
  }

  return {
    hooks: {
      requestAnimationFrame: requestFrame,
      cancelAnimationFrame: cancelFrame
    },
    pause,
    resume,
    dispose,
    isPaused: () => paused,
    installGlobals,
    restoreGlobals
  };
}

let animationController = null;

function resize() {
  canvas.width  = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
}
resize();
window.addEventListener("resize", resize);

editor.value = `
// Core tunnel parameters (feel free to tweak for different vibes)
const HORIZON_STEPS = 1000;
const SECTION_LENGTH = 150;
const CART_SPEED = 0.5;
const TRACK_SPACING = 4.2;
const TIE_STEP = 48;
const CAVE_SLICES = 40;
const CAVE_RADIUS_X = 64;
const CAVE_RADIUS_Y = 84;
const CAVE_JITTER = 8;
const MAX_SLOPE = 4;//Math.tan(Math.PI / 6); // allow ~30 degree pitch
const CURVE_RANGE = 3;
const SPEED_SLOPE_FACTOR = 0.5;
const MIN_FORWARD_SPEED = 1.5;
const MAX_FORWARD_SPEED = 2;

const canvas = c;
const context = ctx;

let half = 0;
let horizonY = 0;

function resizeTunnel() {
  // Keep the perspective square-ish regardless of viewport
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  half = canvas.width / 2;
  horizonY = canvas.height * 0.45;
}

resizeTunnel();
window.addEventListener("resize", resizeTunnel);

class Segment {
  constructor() {
    // Track frame-to-frame offsets plus precomputed geometry
    this.x = 0;
    this.xVel = 0;
    this.y = 0;
    this.yVel = 0;
    this.hasTie = false;
    this.caveRects = [];
  }
}

const segments = Array.from({ length: HORIZON_STEPS }, () => new Segment());

let lastGen = 0;
let cartFloat = 0;
let cart = 0;
let targetCurve = 0;
let targetSlope = 0;
let trackX = 0;
let trackXVel = 0;
let trackY = 0;
let trackYVel = 0;

function pickNewTargets() {
  // Smoothly wander the tunnel left/right and up/down
  targetCurve = (Math.random() - 0.5) * CURVE_RANGE;
  targetSlope = (Math.random() - 0.5) * 2 * MAX_SLOPE;
}

// Create / extend all tunnel segments up to target
function generate(target) {
  for (let i = lastGen; i < target; i++) {
    // Every new section picks a fresh direction bias
    if (i % SECTION_LENGTH === 0) {
      pickNewTargets();
    }

    // Ease velocities toward the chosen curve/slope so motion feels smooth
    trackXVel += (targetCurve - trackXVel) * 0.015;
    trackYVel += (targetSlope - trackYVel) * 0.2;
    trackYVel = Math.max(-MAX_SLOPE, Math.min(MAX_SLOPE, trackYVel));

    trackX += trackXVel * 400;
    trackY += trackYVel * 80;

    const seg = segments[i % HORIZON_STEPS];
    seg.x = trackX;
    seg.xVel = trackXVel * 400;
    seg.y = trackY;
    seg.yVel = trackYVel * 120;
    seg.hasTie = (i % TIE_STEP === 0);
    seg.caveRects.length = 0;

    // Populate an ellipse of rectangles to fake the cave shell
    const wobble = Math.sin(i * 0.05) * 2;
    for (let s = 0; s < CAVE_SLICES; s++) {
      const angle = (s / CAVE_SLICES) * Math.PI * 2;
      const radialJitter = (Math.random() - 0.5) * CAVE_JITTER;
      const radiusX = CAVE_RADIUS_X + wobble + radialJitter;
      const radiusY = CAVE_RADIUS_Y + Math.cos(i * 0.08 + s) * 2 + radialJitter * 0.5;
      seg.caveRects.push({
        angle,
        radiusX,
        radiusY,
        width: 0.8 + Math.random() * 0.5,
        height: 0.4 + Math.random() * 0.2,
        shade: 60 + Math.random() * 80
      });
    }
  }
  lastGen = target;
}

// Project a single segment to screen space and paint it
function drawSegment(i) {
  const d = i - cart;
  if (d <= 0) return;

  const seg = segments[i % HORIZON_STEPS];
  const base = segments[cart % HORIZON_STEPS];

  const scale = half / (d * 0.07 + 2.5); // simple perspective shrink

  const dx = seg.x - base.x - d * base.xVel;
  const dy = seg.y - base.y;

  const centerX = half + (dx * scale) / 6000;
  const centerY = horizonY + (dy * scale) / 6000; // shrink denominator a bit

  const fog = Math.min(1, d / (HORIZON_STEPS * 0.9));
  const depthScaleX = scale * 0.06;
  const depthScaleY = scale * 0.06; // was 0.04

  const railWidth = Math.max(1, scale * 0.8);
  const railHeight = Math.max(2, scale * 16);
  const spacing = scale * TRACK_SPACING;

  // Cave shell as a loose ellipse of uneven rectangles
  for (const rect of seg.caveRects) {
    const ellX = Math.sin(rect.angle) * rect.radiusX;
    const ellY = Math.cos(rect.angle) * rect.radiusY;
    const x = centerX + ellX * depthScaleX * 1.4;
    const y = centerY - ellY * depthScaleY;
    const width = Math.max(2, scale * rect.width + rect.radiusX * 0.05);
    const height = Math.max(4, scale * rect.height + rect.radiusY * 0.15);
    const shade = (rect.shade * (1 - fog * 0.6)) | 0;
    context.fillStyle = 'rgb(' + shade + ',' + shade + ',' + shade + ')';
    context.fillRect(x - width / 2, y, width, height);
  }

  //context.fillStyle = "#373737";
  //context.fillRect(centerX - spacing - railWidth / 2, centerY, railWidth, railHeight);
  //context.fillRect(centerX + spacing - railWidth / 2, centerY, railWidth, railHeight);

  //if (seg.hasTie) {
  //  const tieWidth = spacing * 2.4 + railWidth;
  //  const tieHeight = Math.max(1, scale * 0.9);
  //  context.fillStyle = "#c0c0c0";
  //  context.fillRect(centerX - tieWidth / 2, centerY + railHeight - tieHeight * 2, tieWidth, tieHeight);
  //}
}

function render() {
  // Simple clear + horizon split
  context.fillStyle = "black";
  context.fillRect(0, 0, canvas.width, canvas.height);

  for (let i = lastGen - 1; i >= cart; i--) {
    drawSegment(i);
  }
}

function step() {
  if (cart + HORIZON_STEPS > lastGen - 150) {
    generate(cart + HORIZON_STEPS);
  }

  const seg = segments[cart % HORIZON_STEPS];
  const slopeBoost = seg.yVel * SPEED_SLOPE_FACTOR;
  const forwardStep = Math.max(MIN_FORWARD_SPEED, Math.min(MAX_FORWARD_SPEED, CART_SPEED + slopeBoost));
  cartFloat += forwardStep;
  cart = cartFloat | 0;

  render();
  requestAnimationFrame(step);
}

generate(HORIZON_STEPS);
requestAnimationFrame(step);
`;

function disposeAnimationController() {
  if (animationController) {
    animationController.dispose();
    animationController = null;
  }
}

function runLiveCode() {
  disposeAnimationController();
  resize();

  try {
    const wrappedCode = CODE_PREFIX + editor.value + CODE_SUFFIX;
    animationController = createAnimationController();
    animationController.installGlobals();
    new Function("c","ctx","hooks", wrappedCode)(canvas, ctx, animationController.hooks);
    pauseBtn.textContent = "Pause";
  } catch (e) {
    console.error(e);
    disposeAnimationController();
  }
}

let debounceTimer;
editor.addEventListener("input", () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(runLiveCode, 200);
});

pauseBtn.addEventListener("click", () => {
  if (!animationController) return;
  if (animationController.isPaused()) {
    animationController.resume();
    pauseBtn.textContent = "Pause";
  } else {
    animationController.pause();
    pauseBtn.textContent = "Resume";
  }
});

restartBtn.addEventListener("click", () => {
  runLiveCode();
});

runLiveCode();
</script>

</body>
</html>
