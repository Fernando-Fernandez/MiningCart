<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Mine Cart Tunnel - Live Edit</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: black;
  }
  #container {
    display: flex;
    width: 100vw;
    height: 100vh;
  }
  #c {
    width: 50vw;
    height: 100vh;
    display: block;
    background: black;
  }
  #editor {
    width: 50vw;
    height: 100vh;
    background: #111;
    color: #ddd;
    font-family: monospace;
    font-size: 14px;
    border: none;
    outline: none;
    padding: 8px;
    resize: none;
  }
</style>
</head>
<body>

<div id="container">
  <canvas id="c"></canvas>
  <textarea id="editor"></textarea>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const editor = document.getElementById("editor");
let raf;

function resize() {
  canvas.width  = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
}
resize();
window.addEventListener("resize", resize);

// ------------------------------------------------------------------
// Initial code loaded into editor
// Replace the following string with your entire tunnel code block!
// ------------------------------------------------------------------
editor.value = `
(function () {
  "use strict";

  const HORIZON_STEPS    = 1400;
  const SECTION_LENGTH   = 800;
  const LIGHT_PERIOD     = 400;
  const WALL_STEP        = 10;
  const RAILS_STEP       = 5;
  const STULL_STEP       = 40;
  const STULL_HORIZ_STEP = 20;

  const CART_BASE_SPEED = 1.5;  // slower forward motion
  const WALL_RAD_BASE    = 9.8;
  const LIGHT_FALLOFF    = 1500;

  const canvas = document.getElementById("c");
  const ctx    = canvas.getContext("2d");

  function resize() {
    const s = window.innerHeight;
    canvas.width = s;
    canvas.height = s;
  }
  resize();
  window.addEventListener("resize", resize);

  let half = canvas.width / 2;

  class Block {
    constructor(x, material, w, y, h) {
      this.x = x;
      this.material = material;
      this.w = w;
      this.y = y;
      this.h = h;
    }
  }

  class Segment {
    constructor() {
      this.x = 0;
      this.xVel = 0;
      this.y = 0;
      this.yVel = 0;
      this.light = 0;
      this.lightPhase = 0;
      this.lightBroken = false;
      this.blocks = [];
    }
  }

  const segments = Array.from({length:HORIZON_STEPS}, () => new Segment());

  let lastGen = 0;
  let cartFloat = 0, cart = 0;
  let roomLen = 0;
  let isStalactiteCave = 0;

  // renamed state
  let trackX = 0,
      trackXVel = 0,
      trackY = 0,
      trackYVel = 0,
      prevSlopeDir = 0,
      slopeDir = 0,
      curveDir = 0,
      isRoom = 0,
      wallYOffsetNoise = 0,
      tunnelHeightOffset = 0;

  function generate(target) {
    for (let i = lastGen; i < target; i++) {
      const inSectionIdx = i % SECTION_LENGTH;

      if (inSectionIdx === 0) {
        const sectionIdx = i / SECTION_LENGTH;

        if (sectionIdx & 1) {
          const newSlope = Math.random() > .5 ? 1 : 0;
          slopeDir = -prevSlopeDir + (prevSlopeDir = newSlope);
        } else slopeDir = 0;

        if (!slopeDir && sectionIdx > 0)
          curveDir = (curveDir + 2 + (Math.random() > .5))%3 - 1;

        if (inSectionIdx === 0) {
          isRoom = 0;
          isStalactiteCave = 0;

          if (slopeDir) {
            isRoom = 0; isStalactiteCave = 0;
          }
          else if (sectionIdx > 12 && Math.random() < 0.08) {
            isRoom = 1;
            roomLen = 0;
          }
          else if (sectionIdx > 5 && Math.random() < 0.15) {
            isStalactiteCave = 1;
          }
        }

        if (isRoom) {
          roomLen++;
          if (roomLen > 50) isRoom = 0;
        }

        wallYOffsetNoise = 1.8 * Math.random() - 1;
      }

      tunnelHeightOffset += (inSectionIdx < 160 ? 1 : 0) - (inSectionIdx > 639 ? 1 : 0);

      const seg = segments[i % HORIZON_STEPS];
      seg.blocks.length = 0;

      trackX += trackXVel; trackXVel += curveDir;
      trackY += trackYVel; trackYVel = slopeDir * tunnelHeightOffset;

      seg.x = trackX;
      seg.xVel = trackXVel;
      seg.y = trackY;
      seg.yVel = trackYVel;

      if (!slopeDir) {
        const l = i % LIGHT_PERIOD - LIGHT_PERIOD / 2;
        seg.light = Math.exp(-(l*l) / (2*(LIGHT_PERIOD*LIGHT_PERIOD)/9));
        seg.lightBroken = Math.random() > .95;
      } else seg.light = 0;

      seg.lightPhase = i % LIGHT_PERIOD;

      if (i % WALL_STEP === 0) {
        let R = WALL_RAD_BASE + isRoom * tunnelHeightOffset / 15;
        let zOff = wallYOffsetNoise * isRoom * tunnelHeightOffset / 15;

        for (let g = Math.random() / 6; g < 6.28; g += 2 / R) {
          if (Math.random() < 0.3) continue;
          seg.blocks.push(new Block(
            1.1 * R * Math.cos(g + 11),
            "wall",
            4,
            R * Math.cos(g) + 2 + zOff,
            4
          ));
        }

        if (isStalactiteCave) {
          const isWide = R > WALL_RAD_BASE + 1.0;
          if (isWide) {
            const spikes = 2 + (Math.random()*3)|0;
            for (let n = 0; n < spikes; n++) {
              const ang = Math.random() * Math.PI * 2;
              const cx = 1.1 * R * Math.cos(ang);
              const cy = R + 2 + zOff;
              const len = 3 + Math.random()*4;
              for (let k = 0; k < len; k++) {
                seg.blocks.push(new Block(
                  cx,
                  "stull",
                  1.4,
                  cy - k*0.9,
                  1.1
                ));
              }
            }
          }
        }

        if (!slopeDir && !isRoom) {
          if (i % STULL_STEP === 0) {
            seg.blocks.push(new Block(-6,"stull",1.5,5,14));
            seg.blocks.push(new Block( 6,"stull",1.5,5,14));
          }
          if (i % STULL_HORIZ_STEP === 0) {
            seg.blocks.push(new Block(0,"stull",17,8,3));
          }
        }

        if (seg.lightPhase === 0) {
          seg.blocks.push(new Block(0,"cord",0.2,R+zOff,R+zOff-5));
          seg.blocks.push(new Block(0,"bulb",0.6,5,0.6));
        }
      }

      if (i % RAILS_STEP === 0) {
        seg.blocks.push(new Block(-2,"rail",0.5,-6.5,0.6));
        seg.blocks.push(new Block( 2,"rail",0.5,-6.5,0.6));

        if (i % 40 === 0) {
          if (isRoom) {
            const width  = 12 + Math.random()*6;
            const height = 1.2 + Math.random()*1.5;
            const xshift = (Math.random()-.5) * 4;
            const yshift = (Math.random()-.5) * 1.2;
            seg.blocks.push(new Block(xshift,"stull",
              width, -6.5 + yshift, height
            ));
          } else {
            seg.blocks.push(new Block(0,"stull",17,-6.8,1.5));
          }
        }
      }
    }
    lastGen = target;
  }

  // Lighting stays unchanged
  const MATERIAL = {
    wall:  [10, 110],
    stull: [60, 140],
    rail:  [120,160],
    cord:  [30, 80],
    bulb:  [150,255]
  };

  function shade(material, light, fog, b, seg, dx, dy, segIndex) {
    const [lo, hi] = MATERIAL[material] || [50,150];
    let L = lo + light * (hi - lo);

    if (material === "wall") {
      L = lo;
      const BULB_RADIUS = 200;
      let maxLight = 0;
      for (let k = segIndex - BULB_RADIUS; k <= segIndex + BULB_RADIUS; k++) {
        if (k < 0) continue;
        const near = segments[k % HORIZON_STEPS];
        if (!near.hasBulb || near.lightBroken) continue;
        const dd = Math.abs(k - segIndex);
        const falloff = 1 - dd / BULB_RADIUS;
        if (falloff > maxLight) maxLight = falloff;
      }
      L += maxLight * (hi - lo);
    }

    L *= (1 - fog * 0.6);
    return Math.max(0, Math.min(255, L|0));
  }

  function drawSegment(i) {
    const d = i - cart;
    if (d <= 0) return;

    const seg  = segments[i % HORIZON_STEPS];
    const base = segments[cart % HORIZON_STEPS];

    const f = half / (d/12 + 3);
    const dx = seg.x - base.x - d * base.xVel;
    const dy = seg.y - base.y - d * base.yVel;

    const sxC = half + f * dx / 3000;
    const syC = half + f * dy / 3000;
    const fog = Math.min(1, d / 1000);

    seg.hasBulb = (seg.lightPhase === 0);

    for (const b of seg.blocks) {
      const gray = shade(b.material, seg.light, fog, b, seg, dx, dy, i) | 0;
      ctx.fillStyle = "rgb(" + gray + "," + gray + "," + gray + ")";

      const x = sxC + f*b.x - (f*b.w)/2;
      const y = syC - f*b.y;
      ctx.fillRect(x,y,f*b.w,f*b.h);
    }
  }

  function render() {
    ctx.fillStyle="black";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    for (let i=lastGen-1; i>=cart; i--) drawSegment(i);
  }

  function step() {
    if (cart + HORIZON_STEPS > lastGen - 200)
      generate(cart + HORIZON_STEPS);

    const seg = segments[cart % HORIZON_STEPS];
    cartFloat += CART_BASE_SPEED + seg.y / 30000;
    cart = cartFloat | 0;
    render();
    requestAnimationFrame(step);
  }

  generate(HORIZON_STEPS);
  return requestAnimationFrame(step);
})();

`;

// ------------------------------------------------------------------
// Execution + Live Update
// ------------------------------------------------------------------
let currentRAF = null;

function runLiveCode() {
  // Stop previous animation
  if (currentRAF !== null) {
    cancelAnimationFrame(currentRAF);
    currentRAF = null;
  }

  resize();

  try {
    // The user code must assign its requestAnimationFrame ID
    currentRAF = new Function("c","ctx", editor.value)(canvas, ctx) || null;
  } catch (e) {
    console.error(e);
  }
}

// debounce: wait after typing before re-run
let debounceTimer;
editor.addEventListener("input", () => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(runLiveCode, 200);
});

runLiveCode();
</script>

</body>
</html>
